//! Compatibility tests with hash-sig library
//!
//! These tests verify that the aggregation system works correctly
//! with XMSS signatures generated by the hash-sig library, particularly
//! the Poseidon-based XMSS variant.

use hashsig::{
    MESSAGE_LENGTH,
    signature::{
        SignatureScheme,
        generalized_xmss::instantiations_poseidon::lifetime_2_to_the_18::winternitz::SIGWinternitzLifetime18W1,
    },
};
use sig_agg::{aggregate, AggregationError, AggregationMode, VerificationItem};

type XMSSSignature = SIGWinternitzLifetime18W1;

/// Test: Aggregation with hash-sig Poseidon XMSS signatures
#[test]
fn test_poseidon_xmss_aggregation() {
    let mut rng = rand::rng();
    let (pk, sk) = XMSSSignature::key_gen(&mut rng, 0, 20);

    // Generate signatures using hash-sig library
    let items: Vec<VerificationItem> = (0..10)
        .map(|i| {
            let epoch = i as u32;
            let message = [i as u8; MESSAGE_LENGTH];

            // Sign with hash-sig
            let signature = XMSSSignature::sign(&sk, epoch, &message)
                .expect("hash-sig signing should succeed");

            VerificationItem {
                message,
                epoch,
                signature,
                public_key: None,
            }
        })
        .collect();

    // Aggregate
    let mut batch = aggregate(items, AggregationMode::SingleKey)
        .expect("Aggregation with hash-sig signatures should succeed");

    batch.public_key = Some(pk);

    assert_eq!(batch.items.len(), 10);
    println!("✓ Successfully aggregated 10 hash-sig Poseidon XMSS signatures");
}

/// Test: Verification of hash-sig signatures
#[test]
fn test_hash_sig_signature_verification() {
    let mut rng = rand::rng();
    let (pk, sk) = XMSSSignature::key_gen(&mut rng, 0, 20);

    // Create and verify a single signature
    let epoch = 5u32;
    let message = [42u8; MESSAGE_LENGTH];

    let signature = XMSSSignature::sign(&sk, epoch, &message)
        .expect("Signing should succeed");

    // Verify using hash-sig
    let is_valid = XMSSSignature::verify(&pk, epoch, &message, &signature);

    assert!(is_valid, "hash-sig signature verification should succeed");
    println!("✓ hash-sig signature verification works correctly");
}

/// Test: Aggregation preserves hash-sig signature validity
#[test]
fn test_aggregation_preserves_validity() {
    let mut rng = rand::rng();
    let (pk, sk) = XMSSSignature::key_gen(&mut rng, 0, 20);

    // Create signatures
    let items: Vec<VerificationItem> = (0..5)
        .map(|i| {
            let epoch = i as u32;
            let message = [i as u8; MESSAGE_LENGTH];
            let signature = XMSSSignature::sign(&sk, epoch, &message)
                .expect("Signing should succeed");

            // Verify before aggregation
            assert!(
                XMSSSignature::verify(&pk, epoch, &message, &signature),
                "Signature should be valid before aggregation"
            );

            VerificationItem {
                message,
                epoch,
                signature,
                public_key: None,
            }
        })
        .collect();

    // Aggregate
    let batch = aggregate(items, AggregationMode::SingleKey)
        .expect("Aggregation should succeed");

    // Verify signatures are still valid after aggregation
    for item in &batch.items {
        let is_valid = XMSSSignature::verify(&pk, item.epoch, &item.message, &item.signature);
        assert!(is_valid, "Signature should remain valid after aggregation");
    }

    println!("✓ Aggregation preserves hash-sig signature validity");
}

/// Test: Different Poseidon parameter compatibility
#[test]
fn test_poseidon_parameter_compatibility() {
    // This test verifies that the aggregation system works with
    // the specific Poseidon parameterization used by hash-sig:
    // lifetime_2_to_the_18::winternitz

    let mut rng = rand::rng();
    let (pk, sk) = XMSSSignature::key_gen(&mut rng, 0, 20);

    let epoch = 0u32;
    let message = [0u8; MESSAGE_LENGTH];

    // Create signature with Poseidon-based XMSS
    let signature = XMSSSignature::sign(&sk, epoch, &message)
        .expect("Poseidon XMSS signing should succeed");

    // Verify
    let is_valid = XMSSSignature::verify(&pk, epoch, &message, &signature);
    assert!(is_valid, "Poseidon XMSS signature should verify");

    // Aggregate
    let item = VerificationItem {
        message,
        epoch,
        signature,
        public_key: None,
    };

    let batch = aggregate(vec![item], AggregationMode::SingleKey)
        .expect("Aggregation should work with Poseidon XMSS");

    assert_eq!(batch.items.len(), 1);
    println!("✓ Poseidon parameter set is compatible");
}

/// Test: Epoch constraints from hash-sig
#[test]
fn test_epoch_constraints() {
    let mut rng = rand::rng();

    // Key generated for epochs 0-9
    let (pk, sk) = XMSSSignature::key_gen(&mut rng, 0, 10);

    // Valid epoch (within range)
    let valid_sig = XMSSSignature::sign(&sk, 5, &[0u8; MESSAGE_LENGTH])
        .expect("Signing within epoch range should succeed");

    assert!(
        XMSSSignature::verify(&pk, 5, &[0u8; MESSAGE_LENGTH], &valid_sig),
        "Valid epoch signature should verify"
    );

    // Aggregation should enforce epoch uniqueness
    let items = vec![
        VerificationItem {
            message: [0u8; MESSAGE_LENGTH],
            epoch: 0,
            signature: XMSSSignature::sign(&sk, 0, &[0u8; MESSAGE_LENGTH]).unwrap(),
            public_key: None,
        },
        VerificationItem {
            message: [1u8; MESSAGE_LENGTH],
            epoch: 0, // Duplicate epoch
            signature: XMSSSignature::sign(&sk, 0, &[1u8; MESSAGE_LENGTH]).unwrap(),
            public_key: None,
        },
    ];

    let result = aggregate(items, AggregationMode::SingleKey);
    assert!(
        matches!(result, Err(AggregationError::DuplicateEpoch { epoch: 0 })),
        "Should reject duplicate epochs"
    );

    println!("✓ Epoch constraints enforced correctly");
}
