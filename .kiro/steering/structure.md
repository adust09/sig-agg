# Project Structure

## Root Directory Organization

```
sig-agg-1/
├── .claude/              # Claude Code configuration and slash commands
├── .kiro/                # Kiro spec-driven development files
│   └── steering/         # AI steering documents (this directory)
├── src/                  # Source code directory
│   ├── lib.rs            # Root crate library entry point (sig-agg)
│   └── jolt/             # Jolt zkVM benchmark workspace
├── target/               # Cargo build artifacts (gitignored)
├── tmp/                  # Runtime caches (benchmark data)
├── Cargo.toml            # Root workspace manifest
├── README.md             # Project overview
├── AGENTS.md             # Repository guidelines for AI agents
├── CLAUDE.md             # Project-specific Claude Code instructions
├── LICENSE-MIT           # MIT license
└── LICENSE-APACHE        # Apache 2.0 license
```

### Key Top-Level Files

- **Cargo.toml**: Root workspace manifest defining the `sig-agg` library crate with strict linting configuration
- **README.md**: Project overview and basic usage instructions
- **AGENTS.md**: Comprehensive guidelines for AI agents working in the repository (structure, build commands, coding style, testing, commit practices)
- **CLAUDE.md**: Claude Code-specific instructions including architecture, development commands, and code conventions
- **LICENSE-MIT / LICENSE-APACHE**: Dual licensing under MIT and Apache 2.0

### Key Top-Level Directories

- **src/**: All source code, both root library and Jolt benchmark
- **.kiro/**: Spec-driven development infrastructure (steering, specifications, tasks)
- **.claude/**: Claude Code commands and configuration
- **target/**: Cargo build artifacts (automatically generated, gitignored)
- **tmp/**: Runtime data caches (benchmark signatures, gitignored)

## Subdirectory Structures

### Root Crate (`src/`)

```
src/
└── lib.rs                # Library entry point (currently empty, future aggregation logic)
```

**Purpose**: The `sig-agg` crate will expose aggregation primitives and utilities for XMSS signature aggregation. Currently a placeholder awaiting implementation.

**Key Characteristics**:
- Rust edition 2024 (cutting-edge)
- Strict linting (clippy::all, clippy::nursery, clippy::pedantic)
- Deny-level enforcement of `unused_must_use`
- No dependencies yet (to be added as aggregation logic develops)

### Jolt Benchmark Workspace (`src/jolt/`)

```
src/jolt/
├── src/
│   └── main.rs           # Host orchestrator (main entry point)
├── guest/                # Guest crate (zkVM program)
│   ├── src/
│   │   ├── lib.rs        # Guest program with #[jolt::provable] function
│   │   └── main.rs       # Guest entry point (generated by Jolt)
│   └── Cargo.toml        # Guest crate manifest
├── Cargo.toml            # Jolt workspace manifest
├── rustfmt.toml          # Formatting configuration for Jolt workspace
└── rust-toolchain.toml   # Rust toolchain version specification
```

#### Host Crate (`src/jolt/src/`)

**main.rs** - Orchestrates the complete zkVM workflow:

1. **Setup Phase** (`setup_benchmark_data()`)
   - Generates or loads 1000 XMSS signatures
   - Caches to `./tmp/benchmark_data.bin` for reuse
   - Uses parallel signature generation via rayon

2. **Compilation Phase**
   - Compiles guest program to `/tmp/jolt-guest-targets`
   - Performs Jolt preprocessing (prover and verifier setup)

3. **Proving Phase**
   - Executes guest program inside zkVM
   - Generates zero-knowledge proof
   - Measures proving time and signatures per second

4. **Verification Phase**
   - Verifies the zkVM proof
   - Measures verification time
   - Prints benchmark results

**Key Imports**:
- `hashsig`: XMSS signature scheme (SIGWinternitzLifetime18W1)
- `rayon`: Parallel iterators for signature generation
- `guest`: Types and functions from guest crate

#### Guest Crate (`src/jolt/guest/src/`)

**lib.rs** - The computation proven inside the zkVM:

**Type Definitions**:
- `VerificationItem`: Single signature verification (message, epoch, signature)
- `VerificationBatch`: Complete batch (public key, items vector)
- `BenchmarkedSignature`: Type alias for the specific XMSS variant

**Main Function**:
```rust
#[jolt::provable(memory_size = 10240, max_trace_length = 65536)]
fn verify_signatures(batch: VerificationBatch) -> u32
```

**Functionality**:
- Receives `VerificationBatch` as input
- Iterates over all verification items
- Verifies each signature using `SIGWinternitzLifetime18W1::verify`
- Returns count of valid signatures

**Key Characteristics**:
- No standard library by default (zkVM constraints)
- Serde with `alloc` feature for serialization
- Memory-constrained environment (10 MB memory, 64K trace length)

**main.rs** - Guest entry point (generated by Jolt SDK, not directly edited)

## Code Organization Patterns

### Module Organization

**Root Crate**:
- Single `lib.rs` entry point
- Future modules will be declared here and implemented in `src/<module_name>.rs` or `src/<module_name>/mod.rs`
- Public API exposed through `pub use` re-exports

**Jolt Workspace**:
- **Separation of concerns**: Host (orchestration) vs Guest (proven computation)
- **Shared types**: Guest crate defines types used by both host and guest
- **Type aliases**: Explicit type aliases for complex generic types (e.g., `BenchmarkedSignature`)

### Import Organization

Defined in `src/jolt/rustfmt.toml`:

```toml
reorder_imports = true              # Alphabetical ordering
imports_granularity = "Crate"       # Group by crate
group_imports = "StdExternalCrate"  # Separate std from external
```

**Import Structure**:
1. Standard library imports (std::)
2. External crate imports (hashsig, rayon, etc.)
3. Local crate imports (guest::)

**Example** (from `src/jolt/src/main.rs:1-15`):
```rust
use std::{fs, path::Path, time::Instant};

use hashsig::{
    MESSAGE_LENGTH,
    signature::{
        SignatureScheme,
        generalized_xmss::instantiations_poseidon::lifetime_2_to_the_18::winternitz::SIGWinternitzLifetime18W1,
    },
};
use rayon::{iter::IntoParallelIterator, prelude::*};

use guest::{VerificationBatch, VerificationItem};
```

### Data Type Organization

**Shared Types** (defined in guest, used by both):
- `VerificationItem`: Struct with public fields
- `VerificationBatch`: Struct with public fields
- Both derive `Serialize` and `Deserialize` for zkVM I/O

**Type Aliases**:
- `BenchmarkedSignature = SIGWinternitzLifetime18W1`: Simplifies type annotations
- Associated types: `<BenchmarkedSignature as SignatureScheme>::Signature`

### Function Organization

**Host Functions**:
- `setup_benchmark_data() -> VerificationBatch`: Setup and caching
- `main()`: Top-level orchestration

**Guest Functions**:
- `verify_signatures(batch: VerificationBatch) -> u32`: zkVM-proven computation

### Error Handling Patterns

**Lint Enforcement**: `unused_must_use = deny` requires handling all `Result` values

**Patterns Used**:
1. **Match expressions** with explicit error logging:
   ```rust
   match bincode::deserialize::<VerificationBatch>(&cached_data) {
       Ok(data) => { /* success path */ }
       Err(e) => { println!("Failed: {}, regenerating...", e); }
   }
   ```

2. **Expect for should-not-fail operations**:
   ```rust
   let signature = SIGWinternitzLifetime18W1::sign(...)
       .expect("Signing failed");
   ```

3. **If-let for optional handling**:
   ```rust
   if let Err(e) = fs::create_dir_all(cache_dir) {
       println!("Failed to create cache directory: {}", e);
   }
   ```

## File Naming Conventions

### Source Files

- **Library entry points**: `lib.rs` (crate root)
- **Binary entry points**: `main.rs` (executable root)
- **Module files**: `<module_name>.rs` for single-file modules
- **Module directories**: `<module_name>/mod.rs` for multi-file modules

### Configuration Files

- **Cargo manifests**: `Cargo.toml` (standard Cargo convention)
- **Rust formatting**: `rustfmt.toml` (rustfmt standard)
- **Toolchain specification**: `rust-toolchain.toml` (rustup standard)

### Documentation Files

- **Markdown**: All caps for top-level docs (`README.md`, `AGENTS.md`, `CLAUDE.md`)
- **Lowercase with hyphens** for nested docs (future: `docs/api-reference.md`)

### Cache and Temporary Files

- **Build artifacts**: `target/` directory
- **Guest compilation**: `/tmp/jolt-guest-targets/` (global temp)
- **Benchmark cache**: `./tmp/benchmark_data.bin` (local temp)

## Key Architectural Principles

### 1. Workspace Separation

**Dual-workspace architecture**:
- Root workspace: Library functionality (future aggregation logic)
- Jolt workspace: Benchmarking infrastructure (standalone binary)

**Benefits**:
- Independent versioning and dependencies
- Clear separation of library API from benchmarking tools
- Different Rust editions (2024 vs 2021) for different needs

### 2. Host-Guest Isolation

**zkVM host-guest model**:
- Host: Full standard library, parallel processing, file I/O, caching
- Guest: Constrained environment (limited memory, no I/O, deterministic computation)

**Communication**:
- Serialization boundary (bincode/serde)
- Input: `VerificationBatch` from host to guest
- Output: `u32` (verified count) from guest to host

### 3. Caching for Performance

**Multi-level caching**:
1. **Signature generation cache**: `./tmp/benchmark_data.bin` (persistent across runs)
2. **Guest compilation cache**: `/tmp/jolt-guest-targets/` (Jolt-managed)
3. **Cargo build cache**: `target/` (standard Cargo incremental compilation)

**Cache invalidation**:
- Signature cache: Manual deletion or file corruption
- Guest cache: Managed by Jolt SDK
- Build cache: `cargo clean` or manual deletion

### 4. Parallel Processing

**Parallelism patterns**:
- **Data parallelism**: rayon parallel iterators for signature generation (host-side only)
- **Sequential zkVM**: Guest program executes sequentially within the zkVM
- **Thread safety**: Each rayon thread gets its own RNG (`rand::rng()` per thread)

### 5. Type Safety and Explicitness

**Type system usage**:
- **Associated types**: Leverage trait associated types for signature scheme abstraction
- **Type aliases**: Explicit aliases for complex generic types
- **Derive macros**: Automatic `Serialize`/`Deserialize` implementation
- **No type inference abuse**: Explicit type annotations for clarity

### 6. Lint-Driven Development

**Strict linting configuration**:
- Enable `clippy::all`, `clippy::nursery`, `clippy::pedantic` by default
- Selective `allow` overrides only for truly pedantic cases
- Deny-level enforcement for critical patterns (unused_must_use)
- Workspace-level configuration ensures consistency

### 7. Deterministic Benchmarking

**Reproducibility**:
- Fixed seed or deterministic message generation (`(i + b) as u8`)
- Cached signature data for identical benchmark runs
- Release builds with consistent optimization (`lto = "fat"`, `codegen-units = 1`)
- Scoped key generation (epochs 0 to NUM_SIGNATURES) for consistent setup

### 8. Documentation as Code

**Living documentation**:
- Steering documents (this directory) provide AI-readable project context
- `AGENTS.md` captures repository conventions and workflows
- `CLAUDE.md` provides implementation-level guidance
- Code comments focus on "why" rather than "what" (code is self-documenting)

## File Location Guidelines

### When Adding New Features

**Aggregation logic**: Add to root `src/` directory
- `src/aggregator.rs`: Core aggregation primitives
- `src/batch.rs`: Batch processing utilities
- `src/types.rs`: Shared type definitions
- Expose through `src/lib.rs` with `pub use`

**Benchmarking extensions**: Add to `src/jolt/`
- Host-side setup: Extend `src/jolt/src/main.rs`
- Guest-side computation: Extend `src/jolt/guest/src/lib.rs`
- New zkVM programs: Create new `#[jolt::provable]` functions

**Testing**:
- Unit tests: Colocate in `mod tests` within source files
- Integration tests: Create `tests/` directory at workspace root
- Benchmark tests: Add to `src/jolt/src/main.rs` or create `benches/` directory

### Configuration Files

**Workspace-level**:
- `Cargo.toml`: Workspace manifest and lint configuration
- `rustfmt.toml`: Root formatting configuration (if needed)

**Crate-level**:
- `src/jolt/Cargo.toml`: Jolt workspace and dependencies
- `src/jolt/rustfmt.toml`: Jolt-specific formatting overrides
- `src/jolt/rust-toolchain.toml`: Rust version specification

### Documentation

**Top-level docs**: Root directory
- `README.md`: User-facing overview
- `AGENTS.md`: Developer/AI agent guidelines
- `CLAUDE.md`: Claude Code-specific instructions

**Detailed docs**: `docs/` directory (future)
- `docs/architecture.md`: Deep-dive architectural documentation
- `docs/api.md`: Library API reference
- `docs/benchmarking.md`: Benchmarking methodology

**Steering docs**: `.kiro/steering/`
- `product.md`: Product overview and value proposition
- `tech.md`: Technology stack and development environment
- `structure.md`: This file - project organization and patterns
