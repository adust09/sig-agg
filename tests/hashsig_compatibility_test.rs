//! Compatibility tests with hash-sig library
//!
//! These tests verify that the aggregation system works correctly
//! with XMSS signatures generated by the hash-sig library, particularly
//! the Poseidon-based XMSS variant.

use hashsig::{
    MESSAGE_LENGTH,
    signature::{
        SignatureScheme,
        generalized_xmss::instantiations_poseidon::lifetime_2_to_the_18::winternitz::SIGWinternitzLifetime18W1,
    },
};
use sig_agg::{AggregationError, VerificationItem, aggregate};

type XMSSSignature = SIGWinternitzLifetime18W1;

/// Test: Aggregation with hash-sig Poseidon XMSS signatures
#[test]
fn test_poseidon_xmss_aggregation() {
    let mut rng = rand::rng();
    let (pk, sk) = XMSSSignature::key_gen(&mut rng, 0, 20);

    // Generate signatures using hash-sig library
    let items: Vec<VerificationItem> = (0..10)
        .map(|i| {
            let epoch = i as u32;
            let message = [i as u8; MESSAGE_LENGTH];

            // Sign with hash-sig
            let signature =
                XMSSSignature::sign(&sk, epoch, &message).expect("hash-sig signing should succeed");

            let pk_bytes = bincode::serialize(&pk).unwrap();
            let pk_clone = bincode::deserialize(&pk_bytes).unwrap();

            VerificationItem {
                message,
                epoch,
                signature,
                public_key: pk_clone,
            }
        })
        .collect();

    // Aggregate
    let batch = aggregate(items).expect("Aggregation with hash-sig signatures should succeed");

    assert_eq!(batch.items.len(), 10);
    println!("✓ Successfully aggregated 10 hash-sig Poseidon XMSS signatures");
}

/// Test: Verification of hash-sig signatures
#[test]
fn test_hash_sig_signature_verification() {
    let mut rng = rand::rng();
    let (pk, sk) = XMSSSignature::key_gen(&mut rng, 0, 20);

    // Create and verify a single signature
    let epoch = 5u32;
    let message = [42u8; MESSAGE_LENGTH];

    let signature = XMSSSignature::sign(&sk, epoch, &message).expect("Signing should succeed");

    // Verify using hash-sig
    let is_valid = XMSSSignature::verify(&pk, epoch, &message, &signature);

    assert!(is_valid, "hash-sig signature verification should succeed");
    println!("✓ hash-sig signature verification works correctly");
}

/// Test: Aggregation preserves hash-sig signature validity
#[test]
fn test_aggregation_preserves_validity() {
    let mut rng = rand::rng();
    let (pk, sk) = XMSSSignature::key_gen(&mut rng, 0, 20);

    // Create signatures
    let items: Vec<VerificationItem> = (0..5)
        .map(|i| {
            let epoch = i as u32;
            let message = [i as u8; MESSAGE_LENGTH];
            let signature =
                XMSSSignature::sign(&sk, epoch, &message).expect("Signing should succeed");

            // Verify before aggregation
            assert!(
                XMSSSignature::verify(&pk, epoch, &message, &signature),
                "Signature should be valid before aggregation"
            );

            let pk_bytes = bincode::serialize(&pk).unwrap();
            let pk_clone = bincode::deserialize(&pk_bytes).unwrap();

            VerificationItem {
                message,
                epoch,
                signature,
                public_key: pk_clone,
            }
        })
        .collect();

    let batch = aggregate(items).expect("Aggregation should succeed");

    // Verify signatures still valid after aggregation
    for item in &batch.items {
        let is_valid =
            XMSSSignature::verify(&item.public_key, item.epoch, &item.message, &item.signature);
        assert!(
            is_valid,
            "Signature should remain valid after aggregation"
        );
    }

    println!("✓ Aggregation preserves hash-sig signature validity");
}

/// Test: Serialization/deserialization of hash-sig signatures
#[test]
fn test_hash_sig_signature_serialization() {
    let mut rng = rand::rng();
    let (pk, sk) = XMSSSignature::key_gen(&mut rng, 0, 20);

    let epoch = 0u32;
    let message = [123u8; MESSAGE_LENGTH];
    let signature = XMSSSignature::sign(&sk, epoch, &message).expect("Signing should succeed");

    let pk_bytes = bincode::serialize(&pk).unwrap();
    let pk_clone = bincode::deserialize(&pk_bytes).unwrap();

    let item = VerificationItem {
        message,
        epoch,
        signature,
        public_key: pk_clone,
    };

    let batch = aggregate(vec![item], ).expect("Aggregation should succeed");

    // Serialize batch
    let serialized = bincode::serialize(&batch).expect("Serialization should succeed");

    // Deserialize batch
    use sig_agg::types::AggregationBatch;
    let deserialized: AggregationBatch =
        bincode::deserialize(&serialized).expect("Deserialization should succeed");

    // Verify deserialized signature is still valid
    let item = &deserialized.items[0];
    let is_valid = XMSSSignature::verify(&item.public_key, item.epoch, &item.message, &item.signature);
    assert!(is_valid, "Deserialized signature should be valid");

    println!("✓ hash-sig signatures serialize/deserialize correctly");
}

/// Test: Duplicate epoch detection with hash-sig signatures
#[test]
fn test_hash_sig_duplicate_epoch_detection() {
    let mut rng = rand::rng();
    let (pk, sk) = XMSSSignature::key_gen(&mut rng, 0, 20);

    let message1 = [1u8; MESSAGE_LENGTH];
    let message2 = [2u8; MESSAGE_LENGTH];

    let signature1 = XMSSSignature::sign(&sk, 0, &message1).expect("Signing should succeed");
    let signature2 = XMSSSignature::sign(&sk, 0, &message2).expect("Signing should succeed");

    let pk_bytes = bincode::serialize(&pk).unwrap();
    let pk_clone1 = bincode::deserialize(&pk_bytes).unwrap();
    let pk_clone2 = bincode::deserialize(&pk_bytes).unwrap();

    let items = vec![
        VerificationItem {
            message: message1,
            epoch: 0,
            signature: signature1,
            public_key: pk_clone1,
        },
        VerificationItem {
            message: message2,
            epoch: 0, // Duplicate epoch!
            signature: signature2,
            public_key: pk_clone2,
        },
    ];

    let result = aggregate(items);

    assert!(
        matches!(result, Err(AggregationError::DuplicateKeyEpochPair { epoch: 0, .. })),
        "Should detect duplicate (key, epoch) pair"
    );

    println!("✓ Duplicate (key, epoch) pair detection works with hash-sig");
}
